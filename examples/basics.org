#+TITLE: Basics of Categories and Morphisms
#+AUTHOR: Aidan Pace
#+EMAIL: apace@defrecord.com
#+DATE: 2025-05-11
#+PROPERTY: header-args:scheme :results output :exports both :eval yes :noweb yes :tangle yes
#+PROPERTY: header-args:guile :results output :exports both :eval yes :noweb yes :tangle yes
#+PROPERTY: header-args:mermaid :file ../images/diagrams/:results file :exports both
#+OPTIONS: toc:3 num:3 
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

# Tangle destination for Scheme code
#+PROPERTY: tangle-dir "../src/generated/"

* Categories: The Basic Structure

A category consists of:
- Objects
- Morphisms between objects
- Composition of morphisms
- Identity morphisms for each object

Let's explore these concepts interactively using Guile Scheme.

** Loading the Category Module

First, let's load our category theory module:

#+NAME: module-loading
#+begin_src scheme :tangle ../src/generated/basics-module.scm :mkdirp yes
(add-to-load-path "../src/guile")
(use-modules (category))

(display "Category theory module loaded successfully.\n")
#+end_src

#+RESULTS:
: ;;; compiling ../src/guile/category.scm
: ;;; compiled /home/aygp-dr/.cache/guile/ccache/3.0-LE-8-4.6/home/aygp-dr/projects/aygp-dr/strange-loop-cat/src/guile/category.scm.go
: Category theory module loaded successfully.

** Creating a Simple Category

Let's create a simple category with three objects and some morphisms:

#+NAME: objects-def
#+begin_src scheme :tangle "../src/generated/basics-category.scm"
;; Create objects
(define a (make-object "A"))
(define b (make-object "B"))
(define c (make-object "C"))
#+end_src

#+NAME: morphisms-def
#+begin_src scheme :tangle "../src/generated/basics-category.scm" :noweb yes
;; First include the module loading code
<<module-loading>>

;; Then include object definitions
<<objects-def>>

;; Create morphisms
(define f (make-morphism "f" a b))
(define g (make-morphism "g" b c))

;; Display our objects and morphisms
(display "Objects:\n")
(display a) (newline)
(display b) (newline)
(display c) (newline)

(display "\nMorphisms:\n")
(display f) (newline)
(display g) (newline)
#+end_src

** Composition of Morphisms

One of the key operations in a category is composition of morphisms:

#+NAME: composition
#+begin_src scheme :tangle "../src/generated/basics-composition.scm" :noweb yes
;; First include all the necessary definitions
<<module-loading>>
<<objects-def>>

;; Create morphisms needed for composition
(define f (make-morphism "f" a b))
(define g (make-morphism "g" b c))

;; Compose morphisms g and f
(define g-after-f (compose f g))

(display "Composition g ∘ f: ")
(display g-after-f)
(newline)
#+end_src

** Identity Morphisms

Every object in a category has an identity morphism:

#+begin_src scheme :tangle ../src/generated/demo/basics.scm :mkdirp yes
;; Create identity morphisms
(define id-a (identity a))
(define id-b (identity b))
(define id-c (identity c))

(display "Identity morphisms:\n")
(display id-a) (newline)
(display id-b) (newline)
(display id-c) (newline)
#+end_src

** Visualizing Our Category

Let's visualize our simple category using a Mermaid diagram:

#+begin_src mermaid :file ../images/diagrams/simple-category.png :tangle ../docs/diagrams/simple-category.mmd :mkdirp yes
graph LR
    A((A)) --> |f| B((B))
    B((B)) --> |g| C((C))
    A((A)) --> |"g ∘ f"| C((C))
    A((A)) --> |"id_A"| A((A))
    B((B)) --> |"id_B"| B((B))
    C((C)) --> |"id_C"| C((C))
#+end_src

#+RESULTS:
[[file:../images/diagrams/simple-category.png]]

** Set: A Fundamental Category

The category *Set* is one of the most fundamental categories:
- Objects are sets
- Morphisms are functions between sets
- Composition is function composition
- Identity morphisms are identity functions

Let's implement a simple example of the category Set:

#+begin_src scheme :tangle ../src/generated/demo/basics.scm
;; Define some sets (as lists for simplicity)
(define set-a '(1 2 3))
(define set-b '("a" "b"))
(define set-c '(#t #f))

;; Define functions (these are simplified for demonstration)
(define (func-f x)
  (if (= x 1) "a" "b"))

(define (func-g y)
  (if (string=? y "a") #t #f))

;; Manually apply functions to elements
(display "Applying f to elements of A:\n")
(for-each (lambda (x)
            (format #t "f(~a) = ~a\n" x (func-f x)))
          set-a)

(display "\nApplying g to elements of B:\n")
(for-each (lambda (y)
            (format #t "g(~a) = ~a\n" y (func-g y)))
          set-b)

;; Composing functions
(define (g-compose-f x)
  (func-g (func-f x)))

(display "\nApplying g ∘ f to elements of A:\n")
(for-each (lambda (x)
            (format #t "(g ∘ f)(~a) = ~a\n" x (g-compose-f x)))
          set-a)
#+end_src

* Categorical Properties

** Isomorphisms

An isomorphism in a category is a morphism 
f: A → B for which there exists a morphism 
g: B → A such that g ∘ f = id_A and f ∘ g = id_B.

#+begin_src scheme :tangle ../src/generated/demo/basics.scm
;; Create objects
(define x (make-object "X"))
(define y (make-object "Y"))

;; Create isomorphic morphisms
(define f-xy (make-morphism "f" x y))
(define g-yx (make-morphism "g" y x))

;; Check compositions
(define f-after-g (compose g-yx f-xy))
(define g-after-f (compose f-xy g-yx))

(display "f ∘ g: ") (display f-after-g) (newline)
(display "g ∘ f: ") (display g-after-f) (newline)

;; Compare with identities
(define id-x (identity x))
(define id-y (identity y))

(display "id_X: ") (display id-x) (newline)
(display "id_Y: ") (display id-y) (newline)

;; In a complete implementation, we would check if f-after-g equals id-y
;; and g-after-f equals id-x
#+end_src

** Monomorphisms and Epimorphisms

- A monomorphism (monic) is a morphism f such that for all morphisms
  g₁, g₂: if f ∘ g₁ = f ∘ g₂, then g₁ = g₂

- An epimorphism (epic) is a morphism f such that for all morphisms
  g₁, g₂: if g₁ ∘ f = g₂ ∘ f, then g₁ = g₂

Let's visualize these concepts:

#+begin_src mermaid :file ../images/diagrams/mono-epi.png :tangle ../docs/diagrams/mono-epi.mmd
graph TD
    subgraph "Monomorphism"
    X1((X)) --> |g₁| A1((A))
    X1 --> |g₂| A1
    A1 --> |f| B1((B))
    end
    
    subgraph "Epimorphism"
    A2((A)) --> |f| B2((B))
    B2 --> |g₁| Y2((Y))
    B2 --> |g₂| Y2
    end
#+end_src

* Self-Reference and Strange Loops

** The Concept of Strange Loops

A "strange loop" is a phenomenon where moving through a hierarchical system brings you back to where you started. In category theory, this can be represented by certain kinds of endomorphisms and fixed points.

Let's visualize a simple strange loop:

#+begin_src mermaid :file ../images/diagrams/strange-loop.png :tangle ../docs/diagrams/strange-loop.mmd
graph TD
    A((A)) --> |f| B((B))
    B --> |g| C((C))
    C --> |h| A
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:2px
    style C fill:#bfb,stroke:#333,stroke-width:2px
#+end_src

** Connection to Gödel's Incompleteness Theorem

Gödel's famous theorem uses self-reference to show that in any
consistent formal system strong enough to express basic arithmetic,
there are statements that cannot be proven or disproven within the
system.

This is similar to the concept of initial and terminal objects in
categories, where certain structures cannot be "reached" from within
the system itself.

#+begin_src mermaid :file ../images/diagrams/godel-reference.png :tangle ../docs/diagrams/godel-reference.mmd
graph TD
    A((Formal System)) --> |"Contains"| B((Statements))
    B --> |"Some refer to"| A
    B --> |"Include G"| C(("G: 'G cannot be proven'"))
    C --> |"References"| C
    
    style C fill:#f99,stroke:#333,stroke-width:2px
#+end_src

* Complete Example

Let's put everything together in a complete example that demonstrates
tangling:

#+NAME: complete-category-example
#+begin_src scheme :tangle "../src/generated/complete-basics.scm" :noweb yes
;; First include the module loading code
<<module-loading>>

;; Define objects
<<objects-def>>

;; Create morphisms
(define f (make-morphism "f" a b))
(define g (make-morphism "g" b c))

;; Create identity morphisms
(define id-a (identity a))
(define id-b (identity b))
(define id-c (identity c))

;; Create composition
(define g-after-f (compose f g))

;; Extra objects for isomorphism example
(define x (make-object "X"))
(define y (make-object "Y"))
(define f-xy (make-morphism "f" x y))
(define g-yx (make-morphism "g" y x))
(define f-after-g (compose g-yx f-xy))
(define g-after-f (compose f-xy g-yx))

;; Display results
(display "=== CATEGORY THEORY BASICS ===\n\n")

(display "OBJECTS:\n")
(display a) (newline)
(display b) (newline)
(display c) (newline)
(display x) (newline)
(display y) (newline)

(display "\nMORPHISMS:\n")
(display f) (newline)
(display g) (newline)
(display f-xy) (newline)
(display g-yx) (newline)

(display "\nIDENTITY MORPHISMS:\n")
(display id-a) (newline)
(display id-b) (newline)
(display id-c) (newline)

(display "\nCOMPOSITIONS:\n")
(display "g ∘ f: ") (display g-after-f) (newline)
(display "f ∘ g: ") (display f-after-g) (newline)
(display "f-xy ∘ g-yx: ") (display f-after-g) (newline)
(display "g-yx ∘ f-xy: ") (display g-after-f) (newline)

;; Create a category
(define simple-cat 
  (make-category "SimpleCategory" 
                 (list a b c) 
                 (list f g id-a id-b id-c g-after-f)))

(display "\nCATEGORY:\n")
(display simple-cat) (newline)
#+end_src

* Exercises

1. Create a category with four objects and morphisms that form a
   "square" with compositions along the diagonals.

2. Implement a simple functor between two small categories.

3. Find an example of a strange loop in everyday life and try to model
   it using categorical concepts.

4. Think about how self-reference in programming (recursive functions)
   relates to categorical concepts.

* Exercise Workspace

This section provides a dedicated space to work on the exercises. You can modify the code blocks below, execute them in Emacs, and when you're satisfied with your solutions, you can tangle them back to the appropriate files.

** Exercise 1 Workspace - Square Category

#+NAME: square-category
#+begin_src scheme :tangle "../src/generated/exercises/basics-ex1-square.scm" :mkdirp yes
;; First include the module loading code
(add-to-load-path "../src/guile")
(use-modules (category))

;; Define square category objects
(define a (make-object "A"))
(define b (make-object "B"))
(define c (make-object "C"))
(define d (make-object "D"))

;; Create morphisms for the square
(define f-ab (make-morphism "f_AB" a b))
(define f-bc (make-morphism "f_BC" b c))
(define f-cd (make-morphism "f_CD" c d))
(define f-da (make-morphism "f_DA" d a))

;; Create diagonal morphisms
(define f-ac (make-morphism "f_AC" a c))
(define f-bd (make-morphism "f_BD" b d))

;; Create compositions
(define f-ab-bc (compose f-ab f-bc))  ;; Should be equivalent to f-ac
(define f-bc-cd (compose f-bc f-cd))  ;; Should be equivalent to f-bd
(define f-cd-da (compose f-cd f-da))  ;; Should be equivalent to a loop
(define f-da-ab (compose f-da f-ab))  ;; Should be equivalent to a loop

;; Create a category
(define square-cat 
  (make-category "SquareCategory" 
                 (list a b c d) 
                 (list f-ab f-bc f-cd f-da f-ac f-bd)))

;; Display the category and compositions
(display "SQUARE CATEGORY:\n")
(display square-cat) (newline)

(display "\nCOMPOSITIONS:\n")
(display "f_BC ∘ f_AB: ") (display f-ab-bc) (newline)
(display "f_CD ∘ f_BC: ") (display f-bc-cd) (newline)
(display "f_DA ∘ f_CD: ") (display f-cd-da) (newline)
(display "f_AB ∘ f_DA: ") (display f-da-ab) (newline)
#+end_src

** Exercise 2 Workspace - Simple Functor

#+NAME: simple-functor
#+begin_src scheme :tangle "../src/generated/exercises/basics-ex2-functor.scm" :mkdirp yes
;; First include the module loading code
(add-to-load-path "../src/guile")
(use-modules (category))

;; Create the source category (a simple linear category)
(define s-a (make-object "S_A"))
(define s-b (make-object "S_B"))
(define s-mor (make-morphism "s_mor" s-a s-b))
(define s-id-a (identity s-a))
(define s-id-b (identity s-b))
(define source-cat (make-category "Source" (list s-a s-b) (list s-mor s-id-a s-id-b)))

;; Create the target category (a product category)
(define t-a (make-object "T_A"))
(define t-b (make-object "T_B"))
(define t-c (make-object "T_C"))
(define t-mor1 (make-morphism "t_mor1" t-a t-b))
(define t-mor2 (make-morphism "t_mor2" t-b t-c))
(define t-id-a (identity t-a))
(define t-id-b (identity t-b))
(define t-id-c (identity t-c))
(define target-cat (make-category "Target" 
                                 (list t-a t-b t-c) 
                                 (list t-mor1 t-mor2 t-id-a t-id-b t-id-c)))

;; Define the functor mapping objects
(define (functor-obj obj)
  (cond ((equal? obj s-a) t-a)
        ((equal? obj s-b) t-c)
        (else (error "Object not in source category"))))

;; Define the functor mapping morphisms
(define (functor-mor mor)
  (let ((name (cadr mor))
        (domain (caddr mor))
        (codomain (cadddr mor)))
    (cond ((equal? name "s_mor") 
           (compose t-mor1 t-mor2))  ;; Map s_mor to composite t_mor2 ∘ t_mor1
          ((equal? name "id_S_A") t-id-a)
          ((equal? name "id_S_B") t-id-c)
          (else (error "Morphism not in source category")))))

;; Test the functor
(display "SOURCE CATEGORY:\n")
(display source-cat) (newline)

(display "\nTARGET CATEGORY:\n")
(display target-cat) (newline)

(display "\nFUNCTOR MAPPING:\n")
(display "F(S_A) = ") (display (functor-obj s-a)) (newline)
(display "F(S_B) = ") (display (functor-obj s-b)) (newline)
(display "F(s_mor) = ") (display (functor-mor s-mor)) (newline)
(display "F(id_S_A) = ") (display (functor-mor s-id-a)) (newline)
#+end_src

** Exercise 3 Workspace - Strange Loop Example

#+NAME: strange-loop-example
#+begin_src scheme :tangle "../src/generated/exercises/basics-ex3-strange-loop.scm" :mkdirp yes
;; A real-world example of a strange loop: a thermostat system
;; - Thermostat senses room temperature
;; - Thermostat compares to desired temperature
;; - Thermostat controls heater
;; - Heater changes room temperature
;; - Room temperature is sensed by thermostat (loop back to start)

(define (make-thermostat-system)
  (let ((room-temp 65)
        (desired-temp 70)
        (heater-on #f))
    
    ;; Define the state transformation
    (define (next-state)
      (set! heater-on (< room-temp desired-temp))
      (if heater-on
          (set! room-temp (+ room-temp 1))
          (set! room-temp (- room-temp 0.5)))
      (list room-temp desired-temp heater-on))
    
    ;; Return functions to interact with the system
    (list
     (lambda () (list room-temp desired-temp heater-on))  ; get-state
     (lambda (new-temp) (set! desired-temp new-temp))     ; set-desired-temp
     next-state)))                                        ; advance-system

;; Create a thermostat system
(define system (make-thermostat-system))
(define get-state (car system))
(define set-desired-temp (cadr system))
(define advance-system (caddr system))

;; Simulate the system for a few steps
(display "Initial state: ") (display (get-state)) (newline)

(display "Advancing system...\n")
(dotimes (i 10)
  (display "Step ") (display i) (display ": ")
  (display (advance-system))
  (newline))

;; Change desired temperature and observe system response
(display "\nChanging desired temperature to 65 degrees\n")
(set-desired-temp 65)

(display "Advancing system with new target...\n")
(dotimes (i 10)
  (display "Step ") (display i) (display ": ")
  (display (advance-system))
  (newline))
#+end_src

** Exercise 4 Workspace - Self-Reference in Programming

#+NAME: self-reference-programming
#+begin_src scheme :tangle "../src/generated/exercises/basics-ex4-self-reference.scm" :mkdirp yes
;; Examples of self-reference in programming and their categorical interpretation

;; 1. Y combinator - the classic example of self-reference
(define (Y f)
  ((lambda (x) (f (lambda (y) ((x x) y))))
   (lambda (x) (f (lambda (y) ((x x) y))))))

;; Using the Y combinator to implement factorial
(define factorial
  (Y (lambda (f)
       (lambda (n)
         (if (= n 0)
             1
             (* n (f (- n 1))))))))

(display "Factorial of 5 using Y combinator: ")
(display (factorial 5))
(newline)

;; 2. Self-application - another form of self-reference
(define (self-apply f)
  (f f))

(display "Self-application example: ")
(display (self-apply (lambda (x) (if (procedure? x) "procedure" "not procedure"))))
(newline)

;; 3. Quines - programs that produce their own source code
;; A simple quine in Scheme
(define quine
  '((lambda (x) (list x (list (quote quote) x)))
    (quote (lambda (x) (list x (list (quote quote) x))))))

(display "Quine example: ")
(display quine)
(newline)
(display "Evaluating quine: ")
(display (eval quine (interaction-environment)))
(newline)

;; Categorical interpretation:
;; - Y combinator as a fixed point finder corresponds to finding a fixed point of an endofunctor
;; - Self-application corresponds to a morphism from Hom(A,B) to itself
;; - Quines correspond to a natural transformation from the identity functor to self
#+end_src

