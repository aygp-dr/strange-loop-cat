#+TITLE: Strange Loops and Self-Reference
#+AUTHOR: Jason Walsh
#+EMAIL: j@wal.sh
#+DATE: 2025-05-13
#+PROPERTY: header-args:scheme :results output :exports both :eval yes :noweb yes :tangle yes
#+PROPERTY: header-args:guile :results output :exports both :eval yes :noweb yes :tangle yes
#+PROPERTY: header-args:mermaid :file ../images/diagrams/:results file :exports both
#+OPTIONS: toc:3 num:3 
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

# Tangle destination for Scheme code
#+PROPERTY: tangle-dir "../src/generated/"

* Introduction to Strange Loops

A strange loop is a phenomenon that occurs when, by moving up or down through a hierarchical system, we unexpectedly find ourselves back where we started. This concept was popularized by Douglas Hofstadter in his Pulitzer Prize-winning book "Gödel, Escher, Bach: An Eternal Golden Braid."

Strange loops are integral to many systems that exhibit self-reference, recursion, and emergent complexity. They appear in mathematics, computer science, art, music, and even consciousness itself.

** Loading the Category Theory Module

Let's begin by loading our category theory module:

#+NAME: module-loading
#+begin_src scheme :tangle "../src/generated/strange-loops-module.scm" :mkdirp yes
(add-to-load-path "../src/guile")
(use-modules (category))

(display "Category theory module loaded successfully.\n")
#+end_src

* Types of Strange Loops

Strange loops appear in various forms:

1. **Mathematical Strange Loops**: Like Gödel's Incompleteness Theorems, where statements can refer to themselves.

2. **Computational Strange Loops**: Recursive functions, self-modifying code, and quines (programs that output their own source code).

3. **Artistic Strange Loops**: As seen in M.C. Escher's artwork, such as "Drawing Hands" or the endlessly ascending "Waterfall."

4. **Linguistic Strange Loops**: Self-referential sentences like "This statement is false" (the Liar's Paradox).

5. **Cognitive Strange Loops**: The phenomenon of consciousness, where the brain creates a model of itself.

Let's explore some of these from a categorical perspective:

#+NAME: strange-loop-types
#+begin_src scheme :tangle "../src/generated/strange-loops-types.scm" :noweb yes :mkdirp yes
;; Load the category module
<<module-loading>>

;; Demonstrate different types of strange loops
(display "Types of Strange Loops in Computation:\n\n")

;; 1. Recursive Function - A function that calls itself
(define (factorial n)
  (if (<= n 1)
      1
      (* n (factorial (- n 1)))))

(display "Recursive function (factorial):\n")
(display "factorial(5) = ") (display (factorial 5)) (newline)
(display "The function refers to itself, creating a computational strange loop.\n\n")

;; 2. Fixed-point combinator - A higher-order function that enables recursion
(define (Y f)
  ((lambda (x) (f (lambda (y) ((x x) y))))
   (lambda (x) (f (lambda (y) ((x x) y))))))

(define factorial-Y
  (Y (lambda (f)
       (lambda (n)
         (if (<= n 1)
             1
             (* n (f (- n 1))))))))

(display "Fixed-point combinator (Y):\n")
(display "Y-factorial(5) = ") (display (factorial-Y 5)) (newline)
(display "The Y combinator creates a loop within the lambda calculus itself.\n\n")

;; 3. Self-referential data structure - A structure that contains itself
(define (make-strange-obj name)
  (let ((obj '()))
    (set! obj (list 'strange-obj name obj))
    obj))

(define strange (make-strange-obj "loop"))

(display "Self-referential data structure:\n")
(display "strange = ") 
(display (car strange)) (display " ") 
(display (cadr strange)) (display " ") 
(display (if (eq? (caddr strange) strange) "<self-reference>" (caddr strange)))
(newline)
(display "The object contains a reference to itself, creating a data strange loop.\n")
#+end_src

* Gödel's Incompleteness Theorems and Category Theory

Kurt Gödel's Incompleteness Theorems demonstrate a profound strange loop at the heart of mathematics. They show that in any consistent formal system strong enough to express basic arithmetic, there are statements that cannot be proven or disproven within the system.

This self-reference has categorical interpretations:

#+NAME: godel-categorical
#+begin_src scheme :tangle "../src/generated/strange-loops-godel.scm" :noweb yes :mkdirp yes
;; Load the category module
<<module-loading>>

;; Simulate Gödel numbering with a simple encoding
(define (encode-symbol sym)
  (case sym
    ((+) 1)
    ((*) 2)
    ((=) 3)
    ((0) 10)
    ((s) 11)  ; successor function
    ((p) 12)  ; predicate/property
    ((not) 20)
    ((for-all) 21)
    ((exists) 22)
    (else 99)))  ; other symbols
    
(define (encode-formula formula)
  (if (not (pair? formula))
      (encode-symbol formula)
      (+ (* 100 (encode-formula (car formula)))
         (encode-formula (cadr formula)))))

;; Create some simple formulas
(define formula1 '(= (+ 0 0) 0))  ; 0 + 0 = 0
(define formula2 '(= (+ 0 (s 0)) (s 0)))  ; 0 + 1 = 1

(display "Gödel numbering (encoding formulas as numbers):\n")
(display "Formula: ") (display formula1) (newline)
(display "Encoded: ") (display (encode-formula formula1)) (newline)
(display "Formula: ") (display formula2) (newline)
(display "Encoded: ") (display (encode-formula formula2)) (newline)

;; Create a self-referential formula (conceptual)
(display "\nSelf-reference in formal systems:\n")
(display "Gödel's key insight was to create a formula G that essentially says:\n")
(display "\"Formula with code number G is not provable in the system\"\n")
(display "This creates a strange loop: if G is provable, it's false (contradiction),\n")
(display "and if G is not provable, then it's true but unprovable!\n")

;; Categorical perspective
(display "\nIn category theory, this corresponds to:\n")
(display "- A category of formal statements (objects)\n")
(display "- Morphisms representing proofs or logical implications\n")
(display "- A functor (encoding) from the category to itself\n")
(display "- Certain objects having a 'fixed point' property under this functor\n")
#+end_src

* The Fixed-Point Perspective

Fixed points provide a precise mathematical way to understand strange loops. A fixed point of a function f is a value x such that f(x) = x - the function maps the point back to itself.

In category theory, fixed points take on a richer structure:

#+NAME: fixed-points
#+begin_src scheme :tangle "../src/generated/strange-loops-fixed-points.scm" :noweb yes :mkdirp yes
;; Load the category module
<<module-loading>>

;; Simple fixed point examples
(display "Fixed points in mathematics:\n")

;; A function and its fixed point
(define (f x) (/ (+ x 5) 2))
(define fixed-point 5)  ; f(5) = (5 + 5)/2 = 5

(display "f(x) = (x + 5)/2 has fixed point x = 5\n")
(display "f(5) = ") (display (f 5)) (display " = 5\n\n")

;; Finding fixed points numerically
(define (find-fixed-point f guess tolerance)
  (let ((next (f guess)))
    (if (< (abs (- next guess)) tolerance)
        next
        (find-fixed-point f next tolerance))))

(display "Finding fixed point of f(x) = cos(x) starting from 1:\n")
(define cos-fixed-point (find-fixed-point cos 1 0.0001))
(display "Fixed point ≈ ") (display cos-fixed-point) (newline)
(display "cos(") (display cos-fixed-point) (display ") = ") 
(display (cos cos-fixed-point)) (newline)

;; Categorical perspective on fixed points
(display "\nIn category theory, fixed points appear in many forms:\n")
(display "1. Fixed point objects for endofunctors (solutions to X ≅ F(X))\n")
(display "2. Recursive data types (initial algebras and final coalgebras)\n")
(display "3. Fixed points of natural transformations\n")

;; Implement a simple fixed point object - a list that contains its own tail
(define strange-list '())
(set! strange-list (list 1 2 strange-list))

(display "\nA strange list that contains itself as its own tail:\n")
(display "strange-list = (1 2 ")
(display (if (eq? (caddr strange-list) strange-list) "<self-reference>)" "??)"))
(newline)

;; Implement a recursive data type - binary tree
(define (make-tree value left right)
  (vector 'tree value left right))

(define (tree-value tree) (vector-ref tree 1))
(define (tree-left tree) (vector-ref tree 2))
(define (tree-right tree) (vector-ref tree 3))

(define (leaf value) (make-tree value '() '()))

;; Creating a recursive tree structure
(define t1 (leaf 1))
(define t2 (leaf 2))
(define t3 (make-tree 3 t1 t2))

(display "\nRecursive data structures like trees embody fixed points:\n")
(display "A tree is a value with optional left and right sub-trees\n")
(display "This recursive definition is a fixed point of a functor!\n")
#+end_src

* Strange Loops and Tangled Hierarchies

Hofstadter describes "tangled hierarchies" where levels that should be separate become intermixed, creating strange loops. This happens when a system models itself, leading to self-reference.

Let's explore this with an example from category theory:

#+NAME: tangled-hierarchies
#+begin_src scheme :tangle "../src/generated/strange-loops-tangled.scm" :noweb yes :mkdirp yes
;; Load the category module
<<module-loading>>

;; Create a simple category
(define a (make-object "A"))
(define b (make-object "B"))
(define f (make-morphism "f" a b))

(define cat (make-category "SimpleCategory" (list a b) (list f)))

(display "A simple category:\n")
(display "Objects: A, B\n")
(display "Morphisms: f: A → B\n\n")

;; Now let's create a category of categories (a meta-category)
(define cat-a (make-object "Category-A"))
(define cat-b (make-object "Category-B"))
(define functor-f (make-morphism "Functor-F" cat-a cat-b))

(define meta-cat (make-category "Meta-Category" (list cat-a cat-b) (list functor-f)))

(display "A meta-category (category of categories):\n")
(display "Objects: Category-A, Category-B\n")
(display "Morphisms: Functor-F: Category-A → Category-B\n\n")

;; The tangled hierarchy occurs when we include the meta-category in itself
(display "Tangled hierarchy:\n")
(display "Imagine we put the meta-category back into itself as an object!\n")
(display "This creates a strange loop where a category contains itself.\n\n")

;; In Scheme, we can create this tangle directly:
(define tangled-list '())
(set! tangled-list (list 1 2 tangled-list 3))

(display "A tangled list in Scheme:\n")
(display "(1 2 <self-reference> 3)\n\n")

;; Yoneda Lemma as a form of tangled hierarchy
(display "The Yoneda Lemma creates a kind of tangled hierarchy:\n")
(display "It relates:\n")
(display "1. The 'lower level' - elements of F(A) for an object A\n")
(display "2. The 'higher level' - natural transformations between functors\n")
(display "This creates a tangled loop between levels of abstraction.\n")
#+end_src

* Implementing a Strange Loop System

Let's create a more elaborate example: a system that exhibits strange loop behavior by modeling itself and creating self-reference.

#+NAME: strange-loop-system
#+begin_src scheme :tangle "../src/generated/strange-loops-system.scm" :noweb yes :mkdirp yes
;; Load the category module
<<module-loading>>

;; Define a simple formal system
;; Rules:
;; 1. If we have symbol A, we can derive symbol B
;; 2. If we have symbol B, we can derive symbol A and C
;; 3. If we have symbol C, we can derive symbol D
;; 4. If we have symbol D, we can derive symbol C and A

(define (apply-rules symbols)
  (define result '())
  
  (for-each
   (lambda (s)
     (case s
       ((A) (set! result (cons 'B result)))
       ((B) (set! result (append '(A C) result)))
       ((C) (set! result (cons 'D result)))
       ((D) (set! result (append '(C A) result)))))
   symbols)
  
  ;; Remove duplicates
  (define clean-result '())
  (for-each
   (lambda (s)
     (if (not (member s clean-result))
         (set! clean-result (cons s clean-result))))
   result)
  
  clean-result)

;; Function to iteratively apply rules
(define (derive steps start-symbols)
  (display "Starting with: ") (display start-symbols) (newline)
  (let loop ((i 1)
             (current start-symbols))
    (if (> i steps)
        (begin
          (display "Final symbols: ") (display current) (newline))
        (let ((next (apply-rules current)))
          (display "Step ") (display i) (display ": ") (display next) (newline)
          (loop (+ i 1) next)))))

;; Run the system for a few steps
(display "Running our formal system:\n")
(derive 5 '(A))

;; Now let's encode our system within itself (self-reference)
(display "\nEncoding the system within itself:\n")

;; Rules encoded as pairs (symbol, consequence)
(define rules '((A B) (B A C) (C D) (D C A)))

;; Meta-rule: "If we can derive all symbols on the left of any rule, we can add its right side"
(define (apply-meta-rule symbols rules)
  (define result (append '() symbols)) ; Copy the initial symbols
  
  (for-each
   (lambda (rule)
     (let ((precond (car rule))
           (conseq (cadr rule)))
       (if (member precond symbols)
           (if (not (member conseq result))
               (set! result (cons conseq result))))))
   rules)
  
  result)

;; Add a self-referential rule: "If we have derived the symbol RULES, we can replace all rules"
(define (meta-derive steps start-symbols initial-rules)
  (display "Starting with: ") (display start-symbols) (newline)
  (display "Initial rules: ") (display initial-rules) (newline)
  
  (let loop ((i 1)
             (current start-symbols)
             (current-rules initial-rules))
    (if (> i steps)
        (begin
          (display "Final symbols: ") (display current) (newline)
          (display "Final rules: ") (display current-rules) (newline))
        (begin
          ;; Check for self-modification
          (if (member 'RULES current)
              (begin
                (display "Self-modification triggered at step ") (display i) (newline)
                (set! current-rules (append current-rules '((RULES META) (META RULES))))))
          
          (let ((next (apply-meta-rule current current-rules)))
            (display "Step ") (display i) (display ": ") (display next) (newline)
            (loop (+ i 1) next current-rules))))))

;; Run the self-modifying system
(display "\nRunning our self-modifying system:\n")
(meta-derive 6 '(A RULES) rules)

(display "\nThis system demonstrates a strange loop: the system can reference and modify\n")
(display "itself through its own encoding. This is similar to how Gödel's theorems\n")
(display "work - allowing a formal system to make statements about itself.\n")
#+end_src

* Strange Loops and Consciousness

Hofstadter proposes that consciousness itself is a strange loop - the brain creates a model of both the world and itself, leading to a self-referential system where "I" emerges from this recursive pattern.

While we can't implement consciousness, we can create a simple model of self-awareness:

#+NAME: consciousness-loops
#+begin_src scheme :tangle "../src/generated/strange-loops-consciousness.scm" :noweb yes :mkdirp yes
;; Load the category module
<<module-loading>>

;; A simple model system that has:
;; 1. A world model
;; 2. Actions it can take in the world
;; 3. A model of itself (self-reflection)

;; The world state
(define world-state '(
  (temperature 72)
  (light on)
  (door closed)
))

;; Agent's model of the world (might be different from actual)
(define agent-world-model '(
  (temperature 70)  ; Slightly inaccurate perception
  (light on)
  (door closed)
))

;; Agent's available actions
(define agent-actions '(
  open-door
  close-door
  turn-light-on
  turn-light-off
))

;; Agent's goals
(define agent-goals '(
  (temperature 68)  ; Wants it cooler
  (door open)
))

;; Agent's beliefs about itself - self-model
(define agent-self-model '(
  (goals (temperature 68) (door open))
  (current-action pending)
  (previous-actions ())
  (mental-state thinking)
))

;; This is where the strange loop happens - the self-model contains
;; a representation of itself!
(set! agent-self-model 
      (append agent-self-model 
              `((self-model ,agent-self-model))))

;; Function for the agent to observe itself (self-reflection)
(define (self-reflect)
  (display "Agent reflecting on its own state:\n")
  (display "I want the temperature to be 68°F and the door to be open.\n")
  (display "I believe the temperature is currently 70°F.\n")
  (display "I'm aware that my perception of temperature is sometimes inaccurate.\n")
  (display "I'm currently in a thinking state, deciding what to do next.\n\n")
  
  (display "Strange loop: I'm thinking about the fact that I'm thinking about myself!\n")
  (display "This creates a loop where:\n")
  (display "- I observe the world\n")
  (display "- I observe myself observing\n")
  (display "- I observe myself observing myself observing...\n\n")
  
  (display "This is analogous to Hofstadter's view of consciousness as a\n")
  (display "self-referential pattern or 'strange loop' within our cognitive system.\n"))

;; Execute self-reflection
(self-reflect)

;; In categorical terms:
(display "\nIn category theory, this resembles:\n")
(display "- An endofunctor T representing cognitive transformation\n")
(display "- A natural transformation η: Id ⇒ T representing self-modeling\n")
(display "- A fixpoint of T capturing the strange loop of consciousness\n")
#+end_src

* Exercises

1. Implement a quine in Scheme (a program that outputs its own source code).

2. Design a categorical model of Gödel's Incompleteness Theorem, with objects representing statements and morphisms representing proofs.

3. Create a visual representation of a strange loop using a mermaid diagram that somehow references itself.

4. Implement Russell's Paradox (the set of all sets that don't contain themselves) as a computational structure.

5. Design a system where multiple strange loops interact with each other, creating "tangled hierarchies" of self-reference.

* Tangling Instructions

To tangle this org file and generate the Scheme source files:

1. In Emacs, open this file
2. Use the command: M-x org-babel-tangle
3. Generated files will be created in the ../src/generated/ directory:
   - strange-loops-module.scm
   - strange-loops-types.scm
   - strange-loops-godel.scm
   - strange-loops-fixed-points.scm
   - strange-loops-tangled.scm
   - strange-loops-system.scm
   - strange-loops-consciousness.scm

To run any of the generated files:

```shell
cd ../src/generated
guile strange-loops-system.scm
```