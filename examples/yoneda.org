#+TITLE: The Yoneda Lemma
#+AUTHOR: Aidan Pace
#+EMAIL: apace@defrecord.com
#+DATE: 2025-05-13
#+PROPERTY: header-args:scheme :results output :exports both :eval yes :noweb yes :tangle yes
#+PROPERTY: header-args:guile :results output :exports both :eval yes :noweb yes :tangle yes
#+PROPERTY: header-args:mermaid :file ../images/diagrams/:results file :exports both
#+OPTIONS: toc:3 num:3 
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

# Tangle destination for Scheme code
#+PROPERTY: tangle-dir "../src/generated/"

* Introduction to the Yoneda Lemma

The Yoneda Lemma is one of the most profound and fundamental results in category theory. Though it may appear abstract at first glance, it provides deep insights into the nature of mathematical structures and their relationships.

** What is the Yoneda Lemma?

Informally, the Yoneda Lemma tells us that an object can be completely understood by studying the collection of morphisms *into* it (or *from* it). In other words, an object is fully characterized by how other objects relate to it.

More formally, the Yoneda Lemma states that for any locally small category C and any object A in C, there is a natural bijection between:
- The set of natural transformations from the representable functor Hom(A, -) to any functor F
- The set F(A)

This can be written as:
\[ \text{Nat}(\text{Hom}(A, -), F) \cong F(A) \]

** Loading the Category Theory Module

Let's begin by loading our category theory module:

#+NAME: module-loading
#+begin_src scheme :tangle "../src/generated/yoneda-module.scm" :mkdirp yes
(add-to-load-path "../src/guile")
(use-modules (category))

(display "Category theory module loaded successfully.\n")
#+end_src

* Representable Functors

At the heart of the Yoneda Lemma are representable functors. For an object A in a category C, we have:

- The *covariant* representable functor Hom(A, -): C → Set
- The *contravariant* representable functor Hom(-, A): C^op → Set

Let's implement a simple version of the covariant representable functor:

#+NAME: representable-functor
#+begin_src scheme :tangle "../src/generated/yoneda-representable.scm" :noweb yes :mkdirp yes
;; First load the category module
<<module-loading>>

;; Define a very simple category with a few objects and morphisms
(define a (make-object "A"))
(define b (make-object "B"))
(define c (make-object "C"))

(define f (make-morphism "f" a b))
(define g (make-morphism "g" b c))
(define h (make-morphism "h" a c))

;; A representable functor Hom(A, -) maps:
;; - Each object X to the set of morphisms from A to X
;; - Each morphism m: X → Y to the function that composes m with morphisms A → X

;; Represent Hom(A, X) as a list of morphisms
(define (hom a x category-morphisms)
  (filter (lambda (m)
            (and (equal? (caddr m) a)  ; domain is A
                 (equal? (cadddr m) x))) ; codomain is X
          category-morphisms))

;; All morphisms in our simple category
(define all-morphisms (list f g h))

;; Display representable functor values
(display "Representable functor Hom(A, -):\n")
(display "Hom(A, A): ") (display (hom a a all-morphisms)) (newline)
(display "Hom(A, B): ") (display (hom a b all-morphisms)) (newline)
(display "Hom(A, C): ") (display (hom a c all-morphisms)) (newline)

;; Function that maps morphisms under the representable functor
(define (functor-map-morphism m hom-a-x)
  (map (lambda (morphism-from-a)
         (compose morphism-from-a m))
       hom-a-x))

;; Example: Map morphism g: B → C on Hom(A, B)
(display "\nApplying g: B → C to Hom(A, B):\n")
(let ((hom-a-b (hom a b all-morphisms)))
  (display "Result: ")
  (display (functor-map-morphism g hom-a-b))
  (newline))
#+end_src

* The Yoneda Embedding

The Yoneda embedding is a functor that embeds a category C into the functor category [C^op, Set]. It maps each object A to its representable functor Hom(-, A).

The key insight of the Yoneda Lemma is that this embedding is *full and faithful*, which means it preserves all the structure of the original category.

#+NAME: yoneda-embedding
#+begin_src scheme :tangle "../src/generated/yoneda-embedding.scm" :noweb yes :mkdirp yes
;; First load the category module
<<module-loading>>

;; Define a simple category
(define a (make-object "A"))
(define b (make-object "B"))
(define f (make-morphism "f" a b))

;; Yoneda embedding maps object A to the functor Hom(-, A)
;; We'll represent this mapping symbolically
(display "Yoneda embedding:\n")
(display "y(A) = Hom(-, A)\n")
(display "y(B) = Hom(-, B)\n")

;; For a morphism f: A → B, Yoneda maps it to a natural transformation
;; y(f): Hom(-, A) ⇒ Hom(-, B)
(display "\nYoneda embedding of morphism f: A → B:\n")
(display "y(f): Hom(-, A) ⇒ Hom(-, B)\n")

;; For any object X, y(f)_X: Hom(X, A) → Hom(X, B) is given by 
;; composition with f
(display "\nFor any object X, y(f)_X maps each morphism g: X → A to f ∘ g: X → B\n")

;; Symbolic example
(display "\nExample: For a morphism h: C → A\n")
(display "y(f)_C(h) = f ∘ h: C → B\n")

;; This demonstrates that y is a functor:
;; - It maps objects to objects (in the functor category)
;; - It maps morphisms to morphisms (natural transformations)
;; - It preserves composition and identities
#+end_src

* The Yoneda Lemma Detailed

The Yoneda Lemma provides a natural bijection between:
\[ \text{Nat}(\text{Hom}(A, -), F) \cong F(A) \]

Let's examine what this means in more concrete terms:

#+NAME: yoneda-lemma
#+begin_src scheme :tangle "../src/generated/yoneda-lemma.scm" :noweb yes :mkdirp yes
;; First load the category module
<<module-loading>>

;; Define a simple category
(define a (make-object "A"))
(define b (make-object "B"))
(define c (make-object "C"))
(define f (make-morphism "f" a b))
(define g (make-morphism "g" b c))

;; Suppose we have a functor F: C → Set
;; For simplicity, we'll define F symbolically:
(display "Functor F maps:\n")
(display "F(A) = {a1, a2}\n")
(display "F(B) = {b1, b2, b3}\n")
(display "F(C) = {c1, c2, c4}\n")

;; The Yoneda Lemma states that natural transformations 
;; from Hom(A, -) to F correspond bijectively to elements of F(A)
(display "\nYoneda Lemma states: Nat(Hom(A, -), F) ≅ F(A)\n")

;; How does this bijection work?
(display "\nFor an element a1 ∈ F(A), the corresponding natural transformation α is:\n")
(display "For any object X and any morphism h: A → X,\n")
(display "α_X(h) = F(h)(a1)\n")

;; Example: For the morphism f: A → B
(display "\nExample: For morphism f: A → B\n")
(display "α_B(f) = F(f)(a1) ∈ F(B)\n")

;; Conversely, given a natural transformation β: Hom(A, -) ⇒ F,
;; we get an element of F(A) by evaluating at the identity of A
(display "\nConversely, for a natural transformation β: Hom(A, -) ⇒ F\n")
(display "The corresponding element of F(A) is: β_A(id_A)\n")

;; This bijection is profound: it means that knowing all the ways objects
;; relate to A (via Hom(A, -)) is equivalent to knowing the "value" of
;; any functor F at A
(display "\nThe Yoneda Lemma thus tells us that an object A is completely\n")
(display "determined by how it relates to all other objects (via morphisms).\n")
#+end_src

* Philosophical Implications

The Yoneda Lemma has profound philosophical implications:

1. **Objects are determined by their relationships**: An object is completely characterized by how it relates to other objects. This is similar to how, in real life, we understand things by their relationships to other things.

2. **Perspective matters**: The Yoneda Lemma shows that we can fully understand an object from the "perspective" of morphisms into it. Different perspectives (contravariant vs. covariant) can provide equally valid ways to understand an object.

3. **Connection to Strange Loops**: The Yoneda Lemma involves a kind of self-reference, as it relates how an object interacts with all objects (including itself) to a concrete property of that object.

Let's visualize this with a diagram:

#+begin_src mermaid :file ../images/diagrams/yoneda-concept.mmd
graph TD
    A((A)) --> |"Hom(A,-)"| YA["y(A) = Functor"]
    
    YA --> |"Represents"| RA["All relationships from A"]
    
    RA --> |"Determines"| A
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style YA fill:#bbf,stroke:#333,stroke-width:2px
    style RA fill:#fbb,stroke:#333,stroke-width:2px
#+end_src

* Connection to Strange Loops

The Yoneda Lemma relates to the concept of Strange Loops in several ways:

1. **Self-Reference**: The statement that an object can be understood through its relationships to all objects (including itself) has a self-referential quality.

2. **Tangled Hierarchy**: The Yoneda Lemma establishes a correspondence between:
   - The "lower level" F(A) (a concrete set)
   - The "higher level" Nat(Hom(A, -), F) (natural transformations between functors)
   
   This creates a kind of tangled hierarchy where different levels of abstraction are connected.

3. **Emergent Understanding**: Just as Gödel's Incompleteness Theorem shows how formal systems can make statements about themselves, the Yoneda Lemma shows how categories can "introspect" their own objects.

#+begin_src mermaid :file ../images/diagrams/yoneda-strange-loop.mmd
graph LR
    A((A)) --> |"Perspective"| HOM["Hom(A,-)"]
    HOM --> |"Relates to"| F["Any functor F"]
    F --> |"Evaluated at"| FA["F(A)"]
    FA --> |"Determines"| NT["Natural Transformations"]
    NT --> |"Define"| HOM
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style FA fill:#fbf,stroke:#333,stroke-width:2px
    style NT fill:#fbb,stroke:#333,stroke-width:2px
#+end_src

* Exercises

1. Try to express the Yoneda Lemma in terms of sets and functions rather than categories.

2. Implement a simple functor F: C → Set and verify the bijection given by the Yoneda Lemma for a specific object.

3. How does the Yoneda Lemma compare to other self-referential constructs in mathematics, such as fixed-point theorems?

4. Consider how the Yoneda Lemma relates to the philosophical concept of identity - are things defined by their intrinsic properties or by their relationships to other things?

5. Implement the contravariant version of the Yoneda Lemma using the functor Hom(-, A) and explore the differences.

* Tangling Instructions

To tangle this org file and generate the Scheme source files:

1. In Emacs, open this file
2. Use the command: M-x org-babel-tangle
3. Generated files will be created in the ../src/generated/ directory:
   - yoneda-module.scm
   - yoneda-representable.scm
   - yoneda-embedding.scm
   - yoneda-lemma.scm

To run any of the generated files:

```shell
cd ../src/generated
guile yoneda-lemma.scm
```